type TransferResult = 
 variant {
   err: text;
   ok: nat;
 };
type PurchaseResult = 
 variant {
   err: text;
   ok: Investment;
 };
type PurchaseRequest = 
 record {
   collectionId: text;
   paymentAmount: nat;
   projectId: text;
   quantity: nat;
 };
type ProjectUpdateResult = 
 variant {
   err: text;
   ok;
 };
type ProjectUpdateRequest = 
 record {
   category: text;
   description: text;
   expectedROI: text;
   fundingGoal: nat;
   location: text;
   maxInvestment: opt nat;
   minInvestment: nat;
   projectType: ProjectType;
   riskLevel: text;
   tags: vec text;
   targetDate: opt int;
   timeline: text;
   title: text;
 };
type ProjectType = 
 variant {
   Agriculture;
   Education;
   Energy;
   Environment;
   Finance;
   Healthcare;
   Manufacturing;
   Other;
   RealEstate;
   Services;
   Technology;
 };
type ProjectStatus = 
 variant {
   Active;
   Cancelled;
   Completed;
   Draft;
   Funded;
   InProgress;
   InReview;
   Rejected;
 };
type ProjectResult = 
 variant {
   err: text;
   ok: Project;
 };
type ProjectCreateRequest = 
 record {
   category: text;
   description: text;
   expectedROI: text;
   fundingGoal: nat;
   location: text;
   maxInvestment: opt nat;
   minInvestment: nat;
   projectType: ProjectType;
   riskLevel: text;
   tags: vec text;
   targetDate: opt int;
   timeline: text;
   title: text;
 };
type Project = 
 record {
   category: text;
   createdAt: int;
   description: text;
   expectedROI: text;
   founderId: text;
   founderPrincipal: principal;
   fundingGoal: nat;
   fundingRaised: nat;
   id: text;
   investorCount: nat;
   launchDate: opt int;
   location: text;
   maxInvestment: opt nat;
   minInvestment: nat;
   projectType: ProjectType;
   riskLevel: text;
   status: ProjectStatus;
   tags: vec text;
   targetDate: opt int;
   timeline: text;
   title: text;
   updatedAt: int;
 };
type NFTCollection = 
 record {
   createdAt: int;
   createdBy: principal;
   id: text;
   isActive: bool;
   maxSupply: nat;
   metadata: CollectionMetadata;
   pricePerToken: nat;
   projectId: text;
   totalSupply: nat;
 };
type InvestorUpdateResult = 
 variant {
   err: text;
   ok;
 };
type InvestorRegistrationResult = 
 variant {
   err: text;
   ok: Investor;
 };
type InvestorRegistrationRequest = 
 record {
   email: text;
   fullName: text;
 };
type Investor = 
 record {
   email: text;
   fullName: text;
   id: text;
   isVerified: bool;
   "principal": principal;
   registrationDate: int;
 };
type InvestmentSummary = 
 record {
   amount: nat;
   currentValue: opt nat;
   id: text;
   investmentDate: int;
   projectTitle: text;
   quantity: nat;
   status: InvestmentStatus;
 };
type InvestmentStatus = 
 variant {
   Completed;
   Failed;
   Pending;
   Processing;
   Refunded;
 };
type Investment = 
 record {
   amount: nat;
   collectionId: text;
   founderId: text;
   founderPrincipal: principal;
   id: text;
   investmentDate: int;
   investorId: text;
   investorPrincipal: principal;
   pricePerToken: nat;
   projectId: text;
   quantity: nat;
   status: InvestmentStatus;
   tokenIds: vec nat;
   transactionHash: opt text;
 };
type ICPTransferRequest = 
 record {
   amount: nat;
   memo: opt text;
   to: principal;
 };
type FounderUpdateResult = 
 variant {
   err: text;
   ok;
 };
type FounderRegistrationResult = 
 variant {
   err: text;
   ok: Founder;
 };
type FounderRegistrationRequest = 
 record {
   email: text;
   fullName: text;
   governmentId: text;
   phoneNumber: text;
 };
type Founder = 
 record {
   email: text;
   fullName: text;
   governmentId: text;
   id: text;
   isVerified: bool;
   phoneNumber: text;
   "principal": principal;
   registrationDate: int;
 };
type CreateCollectionRequest = 
 record {
   description: text;
   image: opt text;
   maxSupply: nat;
   name: text;
   pricePerToken: opt nat;
   projectId: text;
   symbol: text;
 };
type CollectionStats = 
 record {
   activeCollections: nat;
   totalCollections: nat;
   totalTokensMinted: nat;
   totalValueLocked: nat;
 };
type CollectionResult = 
 variant {
   err: text;
   ok: NFTCollection;
 };
type CollectionMetadata = 
 record {
   description: text;
   image: opt text;
   name: text;
   supply_cap: opt nat;
   symbol: text;
 };
service : {
  createNFTCollection: (request: CreateCollectionRequest) ->
   (CollectionResult);
  createProject: (request: ProjectCreateRequest) -> (ProjectResult);
  deleteProject: (projectId: text) -> (ProjectUpdateResult);
  founderExistsByEmail: (email: text) -> (bool) query;
  getActiveNFTCollections: () -> (vec NFTCollection) query;
  getActiveProjects: () -> (vec Project) query;
  getAllFounders: () -> (vec Founder) query;
  getAllInvestors: () -> (vec Investor) query;
  getAllProjects: () -> (vec Project) query;
  getFounder: (founderId: text) -> (opt Founder) query;
  getFounderByEmail: (email: text) -> (opt Founder) query;
  getFounderCount: () -> (nat) query;
  getICPTransferFee: () -> (nat) query;
  getInvestment: (investmentId: text) -> (opt Investment) query;
  getInvestmentsForMyProjects: () -> (vec Investment);
  getInvestor: (investorId: text) -> (opt Investor) query;
  getInvestorByEmail: (email: text) -> (opt Investor) query;
  getInvestorCount: () -> (nat) query;
  getInvestorCountForProject: (projectId: text) -> (nat) query;
  getMyFounderProfile: () -> (opt Founder);
  getMyICPBalance: () -> (variant {
                            err: text;
                            ok: nat;
                          });
  getMyInvestmentSummaries: () -> (vec InvestmentSummary);
  getMyInvestments: () -> (vec Investment);
  getMyInvestorProfile: () -> (opt Investor);
  getMyProjects: () -> (vec Project);
  getNFTCollection: (collectionId: text) -> (opt NFTCollection) query;
  getNFTCollectionsByProject: (projectId: text) -> (vec NFTCollection) query;
  getNFTStats: () -> (CollectionStats) query;
  getPlatformStats: () ->
   (record {
      activeProjects: nat;
      totalFounders: nat;
      totalFundingRaised: nat;
      totalInvestments: nat;
      totalInvestors: nat;
      totalProjects: nat;
    }) query;
  getProject: (projectId: text) -> (opt Project) query;
  getProjectCount: () -> (nat) query;
  getProjectsByFounder: (founderId: text) -> (vec Project) query;
  getProjectsByStatus: (status: ProjectStatus) -> (vec Project) query;
  getTotalFundingForProject: (projectId: text) -> (nat) query;
  healthCheck: () -> (text) query;
  investorExistsByEmail: (email: text) -> (bool) query;
  purchaseNFTs: (request: PurchaseRequest) -> (PurchaseResult);
  registerFounder: (request: FounderRegistrationRequest) ->
   (FounderRegistrationResult);
  registerInvestor: (request: InvestorRegistrationRequest) ->
   (InvestorRegistrationResult);
  simulateICPTransfer: (request: ICPTransferRequest) -> (TransferResult);
  submitProjectForReview: (projectId: text) -> (ProjectUpdateResult);
  transferICP: (request: ICPTransferRequest) -> (TransferResult);
  updateFounderVerification: (founderId: text, isVerified: bool) ->
   (FounderUpdateResult);
  updateInvestorVerification: (investorId: text, isVerified: bool) ->
   (InvestorUpdateResult);
  updateMyFounderProfile: (founderId: text, request:
   FounderRegistrationRequest) -> (FounderUpdateResult);
  updateMyInvestorProfile: (investorId: text, request:
   InvestorRegistrationRequest) -> (InvestorUpdateResult);
  updateProject: (projectId: text, request: ProjectUpdateRequest) ->
   (ProjectUpdateResult);
  updateProjectStatus: (projectId: text, newStatus: ProjectStatus) ->
   (ProjectUpdateResult);
}
